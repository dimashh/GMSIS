package gmsis.database;


import gmsis.Log;
import gmsis.database.get.Query;
import gmsis.database.put.UpdateQuery;
import gmsis.database.put.InsertQuery;
import gmsis.database.get.GetResult;
import gmsis.database.delete.DeleteQuery;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Logger;

/**
 * This is a default implementation of a {@link Resolver} it provides a default implementation of get, put and delete
 * using the jdbc driver and assuming sqlite, it provides an abstracted set of methods to be implemented for each
 * object type of resolver needed.
 * @param <T>
 */
public abstract class BaseResolver<T> implements Resolver<T> {

    /**
     * Maps an object to a default delete query, for example given the object it should create a query that deletes
     * that specific object. Usually this is done by selecting the primary key of the object such as id.
     *
     * A default implementation might look something like this
     * return DeleteQuery.builder()
         .table(SomeObjectTable.TABLE)
         .where(SomeObjectTable.COLUMN_ID + " = ?")
         .whereValues(someObject.getId());
     *
     * The above snippet generates a delete query that deletes any objects from the SomeObject table where the unique
     * id matches the id of the object given therefore ensuring only the object passed is deleted
     *
     * @param database The database instance
     * @param object The object
     * @return The delete query
     */
    public abstract DeleteQuery toDeleteQuery(Database database, T object);

    /**
     * Maps an object to a default insert query, for example given the object it should create a query that inserts
     * that specific object.
     * @param database The database instance
     * @param object The object
     * @return The insert query
     */
    public abstract InsertQuery toInsertQuery(Database database, T object);

    /**
     * Maps an object to a default update query, for example given the object it should create a query that updates
     * that specific object.
     * @param database The database instance
     * @param object The object
     * @return The update query
     */
    public abstract UpdateQuery toUpdateQuery(Database database, T object);

    /**
     * This method is called when the object is inserted for the first time into the database, in which case the database
     * will usually generate a new unique primary key for it, this method should be overriden and used to store the
     * generated primary key on the object so it may be later used.
     * @param database The database instance
     * @param object The object to set the id of
     * @param id The id generated by the database
     */
    public abstract void setObjectId(Database database, T object, long id);

    /**
     * Maps a result set from the database as a result of executing a query into an instance of the java object
     * it should return an object type with all the data loaded from the database
     * @param db The database instance
     * @param result The result set from the database
     * @return The object instance
     * @throws SQLException
     */
    public abstract T toObject(Database db, ResultSet result) throws SQLException;

    /**
     * Maps an object into a Map of String to Object where String is a column name in the database and Object is the
     * value for that column, this is used to save the object into the database.
     * @param object The object
     * @return The map of attributes of column names to values
     */
    public abstract Map<String, Object> toValues(T object);

    /**
     * Returns the table name for this object type
     * @return Returns the table name for this resolver and object type
     */
    public abstract String getTableName();

    @Override
    public GetResult<T> get(Database database, Query query) {
        List<T> resultsList = new ArrayList<>();

        try {
            PreparedStatement statement = database.getConnection().prepareStatement(query.toSQL());
            // Set template values
            int i = 1;
            if(query.whereValues() != null) {
                for(Object val : query.whereValues()) {
                    statement.setObject(i++, val);
                }
            }

            Log.trace("GET {0}", query);
            
            ResultSet results = statement.executeQuery();

            while (results.next()) {
                resultsList.add(toObject(database, results));
            }
            
            results.close();
            statement.close();
        } catch (SQLException ex) {
            ex.printStackTrace();
            Log.error("Failed to execute get statement with query {0}", query);
        }
        
        return new GetResult<>(resultsList);
    }

    @Override
    public int put(Database database, T object) {
        Map values = toValues(object);
        UpdateQuery updateQuery = toUpdateQuery(database, object);
        
        int numRows = 0;
        try {
            Query getQuery = Query.builder()
                    .table(updateQuery.table())
                    .where(updateQuery.where())
                    .whereValues(updateQuery.whereValues());
            
            // Create an execute statement
            PreparedStatement statement = database.getConnection().prepareStatement(getQuery.toSQL());
            // Set template values for where section
            int i = 1;
            for(Object val : getQuery.whereValues()) {
                statement.setObject(i++, val);
            }
            ResultSet results = statement.executeQuery();
            // Count rows
            while (results.next()) { 
                ++numRows;
            }
            
            // Close and return
            results.close();
            statement.close();
        } catch (SQLException ex) {
            ex.printStackTrace();
            Log.error("Failed to execute pre-put get statement");
        }
        
        if(numRows == 0) {
            // Perform insert as no other rows exist
            InsertQuery insertQuery = toInsertQuery(database, object);
            try {

                // Create an execute statement
                PreparedStatement statement = database.getConnection().prepareStatement(insertQuery.toSQL(values), Statement.RETURN_GENERATED_KEYS);
                // Set template values for insert section
                int i = 1;
                for(Object val : values.values()) {
                    statement.setObject(i++, val);
                }

                Log.trace("INSERT {0}", updateQuery);

                int rowsAffected = statement.executeUpdate();
                
                if(rowsAffected != 0) {
                    try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
                        if (generatedKeys.next()) {
                            long id = generatedKeys.getLong(1);
                            setObjectId(database, object, id);
                        }
                    }
                }
                
                // Close and return
                statement.close();
                return rowsAffected;
            } catch (SQLException ex) {
                ex.printStackTrace();
            Log.error("Failed to execute insert statement");
            }
        } else {
            // Perform update
            try {
                // Create an execute statement
                PreparedStatement statement = database.getConnection().prepareStatement(updateQuery.toSQL(values));
                int i = 1;
                // Set template values for update section
                for(Object val : values.values()) {
                    statement.setObject(i++, val);
                }
                // Set template values for where section
                for(Object val : updateQuery.whereValues()) {
                    statement.setObject(i++, val);
                }

                Log.trace("UPDATE {0}", updateQuery);

                int rowsAffected = statement.executeUpdate();

                // Close and return
                statement.close();
                return rowsAffected;
            } catch (SQLException ex) {
                ex.printStackTrace();
                Log.error("Failed to execute update statement");
            }
        }
        
        return 0;
    }
    
    @Override
    public int delete(Database database, T object) {
        try {
            DeleteQuery query = toDeleteQuery(database, object);
            // Create an execute statement
            PreparedStatement statement = database.getConnection().prepareStatement(query.toSQL());
            // Set template values for insert section
            int i = 1;
            for(Object val : query.whereValues()) {
                statement.setObject(i++, val);
            }
            int rowsAffected = statement.executeUpdate();

            Log.trace("DELETE {0}", query);

            // Close and return
            statement.close();
            return rowsAffected;
        } catch (SQLException ex) {
            ex.printStackTrace();
            Log.error("Failed to execute delete statement");
        }

        return 0;
    }


    

    
    
}
